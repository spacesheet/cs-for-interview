[%hardbreaks]
톰캣 스레드: HTTP 요청을 처리하는 작업자
DB 커넥션: 데이터베이스 연결 통로
한 개의 톰캣 스레드가 요청을 처리할 때 DB 커넥션을 빌려 쓰고 반납합니다.
톰캣 스레드: 사용  (요청 전체)
DB 커넥션: 사용  (DB 쿼리 실행 시점만)
Java Thread ↔ OS Native Thread (1:1 매핑)
┌─────────────────────────────────────┐
│   Application (Spring Boot)         │
│   - 톰캣 스레드 사용                    │
│   - DB 커넥션 관리                     │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│   JVM (Java Virtual Machine)        │
│   - Java Thread → OS Thread 매핑     │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│   OS (Linux/Windows)                │
│   - Native Thread 관리 (스케줄링)      │
│   - Socket/File Descriptor 관리      │
│   - I/O 시스템 콜                     │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│   Hardware (CPU, Network, Disk)      │
└─────────────────────────────────────┘

[%hardbreaks]
### 사용 관계
클라이언트 요청 -> 톰캣 스레드 1개 할당 (요청 시작~끝) -> 비즈니스 로직 실행 (톰캣 스레드 사용 중)
-> DB 작업 필요할 때만 커넥션 빌림 -> SQL 실행 (Network I/O) -> 커넥션 즉시 반납 (다른 스레드가 재사용)
-> 나머지 로직 실행 (톰캣 스레드 계속 사용) -> 응답 반환 후 톰캣 스레드 반납

[%hardbreaks]
톰캣 스레드 (OS Native Thread):
- CPU 스케줄링 대상
- Context Switching 대상
- 커널이 직접 관리
- /proc/[pid]/task/에서 확인 가능

[%hardbreaks]
톰캣 스레드 (OS Thread):
- 너무 많으면: Context Switching 오버헤드 ↑
- 권장: CPU 코어 수 × 20

[%hardbreaks]
DB 커넥션 (Socket I/O):
- 너무 많으면: DB 서버 부하 ↑
- 권장: 10~50개로 충분
- 이유: 블로킹 I/O 시간 동안 다른 스레드가 재사용
