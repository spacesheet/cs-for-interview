
== 비동기에서의 Zero-cost
Rust의 async/await
컴파일러가 이걸 상태 머신(state machine)으로 변환해서, 런타임에는 거의 직접 짠 상태 머신과 동일한 성능을 냅니다. 추가 할당도 최소화되고요.

cf) Java CompletableFuture
런타임에 객체 할당, 스레드풀 관리, 콜백 체인 관리 등의 오버헤드가 있습니다.

핵심 원리
Rust는 컴파일 타임에 모든 추상화를 해체합니다. 제네릭도 monomorphization(단형화)을 통해 각 타입별로 구체적인 코드를 생성하죠.
쉽게 말해, Rust는 "편하게 작성하되, 실행할 때는 최적화된 기계어로 변환"되는 거라고 보시면 됩니다.

cf) Java는 제네릭 타입 소거(type erasure)로 인해 런타임에 타입 체크나 캐스팅이 필요합니다.



비동기 논블로킹
ex) ocr, 모니터 동시성 제어 매니징

비동기 블로킹
ex) 스트리밍, 화면 캡처링


thread::spawn으로 스레드 생성
join()으로 스레드 완료 대기
move 클로저로 소유권 이동
Arc(Atomic Reference Counting)로 여러 스레드 간 데이터 공유
Mutex로 동시 접근 제어
mpsc::channel로 스레드 간 메시지 전달
